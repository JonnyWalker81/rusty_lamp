/*
 * Copyright Â© 2002-2017 Bluebeam Software, Inc. All Rights Reserved.
 * Creator: Jonathan Rothberg
 */

use std::sync::Arc;
use std::io::{Write, BufWriter};
use std::fs::{File};
use std::collections::{HashSet};
use generator::generator::{Generate};
use generator::spec::Spec;
use generator::cpp_marshaler::CppMarshaler;
use parser::program::Program;
use parser::ast::{StatementKind};

pub struct CppGenerator {
    
}

struct CppRefs {
    hpp_includes: HashSet<String>,
    hpp_fwds: HashSet<String>,
    cpp_includes: HashSet<String>
}

impl CppRefs {
    fn new() -> CppRefs {
        CppRefs {
            hpp_includes: HashSet::new(),
            hpp_fwds: HashSet::new(),
            cpp_includes: HashSet::new()
        }
    }
}

impl CppGenerator {
    pub fn new() -> CppGenerator {
        CppGenerator {
            
        }
    }

    fn write_header(&self, w: &mut Write) {
        writeln!(w, "// AUTOGENERATED FILE - DO NOT MODIFY!");
        writeln!(w, "// This file was generated by rusty_lamp");

        writeln!(w, "#pragma once");
    }

    fn wrap_with_namespace<F>(&self, w: &mut Write, ns: String, block: F) where F: Fn(&mut Write)  {
        writeln!(w, "namespace {} {{", ns);
        block(w);
        writeln!(w, "}} // {}", ns);
    }
}

impl Generate for CppGenerator {
    fn write_enum(&self, e: &StatementKind, spec: &Spec) {
        if let StatementKind::Enum(_, ref i, ref b) = *e {
            println!("Generating Enum: {}", i.value);
            let mut w = self.make_writer(spec, &i.value);
            self.write_header(&mut w);

            let mut cpp_refs = CppRefs::new();
            cpp_refs.hpp_includes.insert("#include <functional>".into());
            
            cpp_refs.hpp_includes.iter()
                .filter(|x| x.len() > 0)
                .inspect(|inc| writeln!(w, "{}", inc).unwrap_or_default())
                .collect::<Vec<_>>();
            
            self.wrap_with_namespace(&mut w, "namespace_gen".into(), |w| {
                writeln!(w, "enum class {} : int {{", i.value);
                b.statements
                    .iter()
                    .inspect(|o| {
                        match o.stmtKind {
                            StatementKind::EnumMember(_, ref oi) => {
                                writeln!(w, "{},", oi.value);
                            },
                            _ => {}
                        }
                    })
                    .collect::<Vec<_>>();
                writeln!(w, "}};");
            });

            self.wrap_with_namespace(&mut w, "std".into(), |w| {
                writeln!(w, "template<>");
                writeln!(w, "struct hash<::namespace_gen::{}> {{", i.value);
                writeln!(w, "size_t operator()(::namespace_gen::{} type) const {{", i.value);
                writeln!(w, "return std::hash<int>()(static_cast<int>(type));");
                writeln!(w, "}}");
                writeln!(w, "}};");
            });
            
        }
    }

    fn write_record(&self, r: &StatementKind, spec: &Spec) {
        if let StatementKind::Record(_, ref i, ref bs, ref dt) = *r {
            let marshaler = CppMarshaler::new();
            println!("Generating Record: {}", i.value);
            let mut w = self.make_writer(spec, &i.value);

            let mut cpp_refs = CppRefs::new();

            bs.statements
                .iter()
                .inspect(|stmt| {
                match stmt.stmtKind {
                    StatementKind::RecordMember(_, ref id, ref dts) => {
                        println!("{}", dts);
                        let include = marshaler.include(dts);
                        if include.len() > 0 {
                            cpp_refs.hpp_includes.insert(format!("#include {}", include));
                        }
                    },
                    _ => {}
                }
                })
                .collect::<Vec<_>>();

            self.write_header(&mut w);
            cpp_refs.hpp_includes
                .iter()
                .filter(|x| x.len() > 0)
                .map(|inc| writeln!(w, "{}", inc))
                .collect::<Vec<_>>();

            writeln!(w, "");
            self.wrap_with_namespace(&mut w, "namespace_gen".into(), |w| {
                writeln!(w, "struct {} {{", i.value);
                for f in &bs.statements {
                    match f.stmtKind {
                        StatementKind::RecordMember(_, ref id, ref dts) => {
                            let t = spec.typer.get(&dts.get_name());
                            writeln!(w, "{} {};", marshaler.get_type_name(t), id.value);
                        },
                        _ => {}
                    }
                }
                writeln!(w, "}};");
            });
        }
    }

    fn write_interface(&self, i: &StatementKind) {
        
    }

    // fn make_writer(&self, spec: &Spec, file_name: String) -> Write{
    //     // Open a file in write-only mode, returns `io::Result<File>`
    //     let path = format!("{}/{}/{}.hpp", spec.root, spec.cpp_root, file_name);
    //     let mut file = match File::create(&path) {
    //         Err(why) => panic!("couldn't create {}: {}",
    //                         path,
    //                         why.description()),
    //         Ok(file) => file,
    //     };

    //     file
    // }
}
